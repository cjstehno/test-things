== JUnit 5 Extensions

An interesting, and useful part of JUnit 5 is the https://junit.org/junit5/docs/current/user-guide/#extensions[Extension Mechanism].
You can quickly and easily add extensions to make your testing easier and more robust.

The test-things library provides a handful of extensions to aid in test simplification.

=== LifecycleExtension

The `LifecycleExtension` is an extension used to an occasional gap in the JUnit extension framework - specifically around how the before and after callbacks are applied.

Consider the case when you have an extension configured in a test as follows:

[source,java]
----
@ExtendWith(HelpfulExtension.class)
class SomeInterestingTest {

    private DataProvider provider;

    @BeforeEach void beforeEach(){
        provider = configureProvider();
        provider.start();
    }

    @AfterEach void afterEach(){
        provider.shutdown();
    }

    // Tests that use the provider with the extension
}
----

Here we have a (fictional) `DataProvider` that must be configured in a specific manner for the test; however, this `DataProvider` is also discovered by the `HelpfulExtension`. The problem is that the `@BeforeEach` and `@AfterEach` annotated methods are executed _after_ those provided by the extension, meaning that depending on how the extension is written, you may not have the `provider` populated when you need it - if it's your extension you can modify the extension to resolve this issue, but if the extension is from a 3rd party you need to find another approach.

That's where the `LifecycleExtension` comes into play. If you add it _before_ the `HelpfulExtension` in the list of extensions and then modify the two configuration methods as follows:

[source,java]
----
@ExtendWith({LifecyleExtension.class, HelpfulExtension.class})
class SomeInterestingTest {

    private DataProvider provider;

    @Lifecycle(BEFORE) void beforeEach(){
        provider = configureProvider();
        provider.start();
    }

    @Lifecycle(AFTER) void afterEach(){
        provider.shutdown();
    }

    // Tests that use the provider with the extension
}
----

The `LifecycleExtension` will now execute _before_ the `HelpfulExtension`. What this extension does is look for the methods annotated with a `@Lifecycle` annotation, of which there are four types: `BEFORE_ALL`, `BEFORE_EACH`, `AFTER_EACH`, and `AFTER_ALL`, mapping to the standard JUnit 5 lifecycle callbacks of the same name.

When the test executes, the `LifecycleExtension` will find all of the lifecycle-annotated methods and execute them in the order they are discovered, then the other extensions will be applied, and then finally the callbacks for the test itself.

In our example, the `beforeEach()` and `afterEach()` methods are called early enough to configure the `provider` instance so that everything works as it should.

Similarly, the extension has support for `BEFORE_ALL` and `AFTER_ALL` static lifecycle methods.

Note that the types of method allowed for each lifecycle extension point is as follows:

[cols="1,1"]
|===
|Lifecycle Point |Method modifier

|`BEFORE_ALL`
|`static`

|`BEFORE_EACH`
|non-`static`

|`AFTER_EACH`
|non-`static`

|`AFTER_ALL`
|`static`
|===

TIP: If your lifecycle annotated methods are not being executed, be sure that your method signature meets the criteria described above.

=== DatabaseExtension

The `DatabaseExtension` is provided as a framework-agnostic means of setting up and tearing down a database, using a provided `DataSource` instance.

> #FIXME:# add the new setupDataSource, tearDownDataSource methods


=== SharedRandomExtension

helpful when using shared-random for testing

=== SystemPropertiesExtension

sometimes you need to chnage system props during testing

=== ResourcesExtension

The `ResourcesExtension` provides for the injection of classpath resource paths or content based on object type annotated with the `@Resource` annotation - the supported types are as follows:

* A `Path` will be populated with the path representation of the provided classpath value.
* A `File` will be populated with the file representation of the provided classpath value.
* A `String` will be populated with the contents of the file at the classpath location, as a String.
* An `InputStream` will be populated with the content of the file at the classpath location, as an InputStream.
* A `Reader` will be populated with the content of the file at the classpath location, as a Reader.
* A byte array (`byte[]`) will be populated with the content of the file at the classpath location, as a array of bytes.
* Any other object type will attempt to deserialize the contents of the file at the classpath location using the configured `serdes` value of the annotation (defaulting to `JacksonJsonSerdes` if none is specified.

The annotated types may be:

* *Static Fields.* A `static` field annotated with the `@Resource` annotation will be populated during the "BeforeAll" callback.
* *Non-Static Fields.* A non-`static` field annotated with the {@link Resource} annotation will be populated during the "BeforeEach" callback.
* *Callback or Test Method Parameters.* A lifecycle callback or test method parameter annotated with the `@Resource` annotation will be populated when that method is called by the test framework.

A contrived example could look something like the following:

[source,java]
----
@ExtendWith(ResourcesExtension.class)
class SomeTest {
    @Resource('/resource-01.dat') static byte[] resourceData;   // injected during BeforeAll
    @Resource('/resource-02.txt') String someText;              // injected during BeforeEach

    @Test void testing(@Resource(value="/person.xml", serdes=JacksonXmlSerdes.class) final Person person){
        // testing with the instantiated person (from xml)
    }
}
----

The resource loading provided by this extension delegates to the `Resources` utility methods, which may be used directly - this extension provides a simplification framework for common use cases.

NOTE: All injected fields will be cleared (set to null) during the appropriate "after" callback.

